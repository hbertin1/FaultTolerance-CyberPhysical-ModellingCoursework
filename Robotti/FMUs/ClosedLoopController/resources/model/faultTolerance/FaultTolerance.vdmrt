class FaultTolerance

    types 
        Mode  = <INIT> | <ERROR_DETECTION> | <DAMAGE_CONFINEMENT> | <ERROR_RECOVERY> | <FAULT_TREATMENT>;
       
    
    instance variables
        public static errorDetection : [ErrorDetection] := nil;
        -- public static damageConfinement : [DamageConfinement] := nil;
        public static errorRecovery : [ErrorRecovery] := nil;
        -- add fault treatment ?
        -- test
        public static mode : Mode := <INIT>;
        public static last_pos : seq of real :=  [0.0, 0.0, 0.0, 0.0];

    operations
        public FaultTolerance :  () ==> FaultTolerance
        FaultTolerance() == (
            mode := <INIT>;
            errorDetection := new ErrorDetection(last_pos);
            errorRecovery := new ErrorRecovery(last_pos);
        );

        public check : seq of real * real * real ==> seq of real
        check(pos, speed, steering) == (                        -- speed and steering are the value given to the Model at Step-1                          -- It's excepted value not real values
            dcl fault : Fault;
            if mode = <INIT> then mode := <ERROR_DETECTION>     -- maybe add init time
            else if mode = <ERROR_DETECTION> then (
                fault := errorDetection.detect(pos, speed);
                if fault.isDetected() then mode := <ERROR_RECOVERY>;
            );
            -- if mode = <DAMAGE_CONFINEMENT> then (
            --     if damageConfinement.confine(pos) then mode := <ERROR_RECOVERY>;
            --     ret := true;
            -- );
            if mode = <ERROR_RECOVERY> then (
                mode := <ERROR_RECOVERY>;
                errorRecovery.recover(pos, fault, speed);
            );
            return pos;
        );

end FaultTolerance